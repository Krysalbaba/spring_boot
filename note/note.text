docker :
1 修改pom文件后   利用maven打包(注意pom文件中的ip地址)
2 注意打包生成的jar包和dockerfile 中的 copy指令的jar包是否一致
3 package后会生成一个镜像
4 指定运行端口和绑定端口和ip地址(docker容器地址)
5 直接运行

ps : 更改完配置后  打包之前在idea里重新连接 docker容器

redis :
1 集成redis后 先将redis自带的序列化方法换成Jackson2JsonRedisSerializer序列方法
2 根据常用程度考虑是否编写工具类

ps : redis 不支持 localdatetime 时间格式 需要在配置文件中格式化 或者通过注解的形式解决问题


rabbit :
    1.延时队列
        原理:创建一个死信交换机 并设置消息过期时间  在消息过期时转发给普通队列中  监听并消费普通队列
        步骤:
             1,创建一个死信队列并设置消息过期时间(也可以不设置 在发送消息时通过时间函数去设置) 指定消息过期后转发的交换机及其路由key
               创建一个普通队列
             2,创建一个死信交换机和一个普通交换机
             3,将死信队列和死信交换机和死信路由key 绑定
               将普通队列和普通交换机和普通路由key 绑定
             4,发送消息(如果创建死信队列时 未指定过期时间则需要在发送时通过函数去指定过期时间)
             5,监听普通队列
    2.java和python端互传消息
       planA :
             暂时采用fanout方式创建一个交换机绑定两个队列 利用特性将产生的消息通过交换机发送到所绑定的队列中 然后进行消费
       planB :
             考虑采用其他技术栈  实现一条消息多次消费
    3.direct 模式
       步骤 :
             1,创建一个direct共用交换机
             2,创建两个队列
             3,将交换机和2个队列及其路由绑定
             4,创建生产者指定交换机及路由及数据
             5,监听队列  消费信息
       ps : 发送消息时必须指定交换机和路由key
    4.topic 模式
       步骤 :
             1,创建一个topic共用交换机
             2,创建三个队列便于测试
             3,将队列与交换机与通配符路由(routing.demo.* 或者 routing.# 或者 #.demo.*)绑定
             4,创建生产者指定交换机及路由及数据
             5,监听队列  消费信息
       理解 :
             发送消息时路由是固定的 根据绑定关系选择一个或多个符合条件的队列 然后去队列中消费集合
       ps  :
             通配符路由是写在 步骤第三步中
             监听的队列和发送消息时 路由和队列是没有通配符匹配的
    5.headers 模式
       步骤 :
             1,创建一个headers共用交换机
             2,创建两个个队列便于测试
             3,将队列与交换机与headers绑定 并设置headers参数
             4,创建生产者指定交换机设置头部及数据
             5,监听队列  消费信息
       理解 :
             发送消息时根据你设置的头部消息和绑定队列时设置的头部对比  any 为其中一条符合就可以  all则需要所有头部匹配
       ps  :
             whereAll或whereAny中 只要参数接map后面必须是.match  参数是多个字符串则接 .exist
             exist方法只是把传入的字符串key 变成的map的key值 map的value值为空
mybatis plus :
ps : save 方法后会修改你保存的实体类 例如实体类getId可以直接拿到id的值
     但是并没有查询数据库 数据库中设为默认的值get出来依然为null
